新增：/api/subject/insert
编辑：/api/subject/update
详情：/api/subject/selectSubjectDetailByIdOrInstanceId
注册地下拉选项框：/api/subject/getTypes  
变更记录：/api/subjectChange/getSubjectChangeList



①、

1-连接
2-查询缓存
查询缓存，但是在mysql8之后就没有缓存了，因为缓存的要求非常的高，首先它对大小写、空格等都必须一样才能算是同一个sql语句，同时如果一张表的数据发生了任何变化这张表对应的缓存就会被清空。
3-语法解析和预处理
解析分为词法解析和语法解析：
词法解析：把sql语句打碎成一个个的单词
语法解析：先做一些语法检查看有没有错误的语法，比如引号有开有闭等，然后根据mysql的语法规则解析成一个数据结构（解析树）
预处理：在解析成为数据结构的时候会通过一个预处理器对生成的数据结构进行判断，比如判断我们的表在数据库中是否存在，查询的字段是否存在，并且是否有别名等，所以经过预处理之后我们的数据结构就会发生变化（比如别名的替换等）
4-sql语句优化并获得执行计划
这里的执行计划是一种数据结构，优化器就是将解析树优化成为执行计划

5-现在数据有了，我们要存储数据到哪里呢，这就需要先组织一个数据结构来存储我们的数据，而这个存储数据的数据结构就是我们常说的存储引擎（innoDB，也叫做表类型）

6-最后就是我们使用执行引擎把我们的执行计划去操作存储引擎的，不管我们使用哪一种存储引擎，但是我们的sql语句也不需要变查询的结果都是一样的，那是因为不同的存储引擎实现的API是相同的。

innoDB和MYISAM的区别：
innoDB支持表锁和行所，MYISAM只支持行所。
innoDB支持事务，MYISAM不支持事务
innoDB支持外键，MYISAM不支持外键


②、缓存


③、事务
事务的四大特性：ACID：原子性、隔离性、一致性、持久性
事务并发造成的问题：脏读（其他事务没有提交的数据被读到）、不可重复读（其他事务提交的事务被读到）、幻读（其他事务新增的数据被读到）
                                   不可重复读是修改和删除，幻读是新增
四种隔离级别：未提交读、提交读、可重复读、串行读

事务的隔离实现方式：
LBCC（基于锁的并发控制）：一个事务读取的时候不允许其他事务修改
MVCC（多版本并发控制）：InnoDB为数据库中的每条数据都增加了两个隐藏字段（一个是创建版本号，一个是删除版本号）
                                             只能查询创建时间小于等于把当前事务id的数据和删除时间大于当前事务id的数据
在innoDB中是上面两种方式协同使用的

LBCC的实现是锁机制，下面我们聊聊innoDB的锁机制：
锁的分类：两个行级别的锁（共享锁、排他锁），两个表级别的锁（意向共享锁、意向排他锁），以及记录锁、间隙锁、临界锁

行锁的原理是锁住了索引
为什么表里面没有索引的时候，锁住一行数据会导致锁表？是因为查询没有使用索引，会进行全表扫描，然后把每一个隐
藏的聚集索引都锁住了

innoDB能够在可重复读的级别中就能够防止幻读就是因为innoDB中默认使用了临界锁

④、性能优化





=======================================================================
ArrayList的初始容量是10、扩容每次是原来的1.5倍。
HashMap的连边的默认初始容量是16，负载因子是0.75，以后每次扩容是原来的2倍，并且数组的长度必须是2的幂次方。










